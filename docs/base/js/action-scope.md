# 作用域
ES5中定义了全局作用域和函数作用域，ES6中新增了块级作用域。
## 作用域链
每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，无法访问，但解析器会使用。
全局作用域就是最外围的执行环境，在web中`window`是全局执行环境，某个执行环境中的所有代码执行完后，该环境被**销毁**，保存在其中的**所有变量**和**函数定义**也随之**销毁**。
当代码在一个环境中执行时，会创建变量对象的一个**作用域链**，用途是保证对执行环境有权访问的所有变量和函数的有序访问。如果这个环境是**函数**，则包含最初始的**arguments**。
作用域链中的下一个变量对象来自外部环境，**层层递进**，直到**全局执行环境**。
标识符解析式沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链前端开始，然后逐级的 向后回溯，直到找到标识符为止（找不到，通常会导致错误发生）。
with和try-catch的catch可以延长作用域链，但with会影响性能，不推荐使用。

## 闭包
闭包是指有权访问另一个函数作用域中的变量的函数。
如果函数 A 把函数 B 作为返回值返回时，情况又不一样。首先，函数 A 返回的是函数 B 的引用，也就是说，B 可能会在其他地方被调用。上面提到，函数 B 的定义是位于函数 A 内部，因此 A 和 B 会形成一条作用域链，函数 B 有可能会读取 A 中的变量 。为了保证函数 B 能够在其他地方正确执行，函数 B 所在的这条作用域链就不能被破坏。所以，即使函数 A 执行返回后，A 的作用域也不能释放，需要一直保存在内存中，以确保函数 B 能够正常读取里面的变量。函数 B 具有永久访问 A 作用域的特权，确切说，函数 B 就是闭包 。
``` js
function a(){
    var temp=1
    return function b(){
        console.log(temp)
    }
}
var fun=a()  // b能访问a的作用域中变量,且a的作用域不会释放
```
**闭包跟return是既不充分也不必要的关系**
``` js
(function (){  
    var a = 10;  
    add.onclick = function (){  
        a++;  
        span.innerHTML = a;  
    }          
})()
```
## this
`this`的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定`this`到底指向谁，实际上`this`的最终指向的是那个**调用**它的对象，`this`的指向在**函数创建**的时候是决定不了的，在**调用**的时候才能决定，谁调用的就指向谁。
- 如果一个函数中有`this`，但是它没有被上一级的对象所调用，那么`this`指向的就是`window`（非严格模式）。
- 如果一个函数中有`this`，这个函数有被上一级的对象所调用，那么`this`指向的就是上一级的对象。
- 如果一个函数中有`this`，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，`this`指向的也只是它上一级的对象。
``` js
var o = {
    a:10,
    b:{
        // a:12,
        fn:function(){
            console.log(this.a); //undefined
        }
    }
}
o.b.fn();
```
尽管对象b中没有属性a，这个`this`指向的也是对象b，因为`this`只会指向它的上一级对象，不管这个对象中有没有`this`要的东西。

**构造函数版this：**
``` js
function Fn(){
    this.user = "追梦子";
}
var a = new Fn();
console.log(a.user); //追梦子
```
这里之所以对象a可以点出函数Fn里面的user是因为`new`关键字可以改变`this`的指向，将这个`this`指向对象a，为什么我说a是对象，因为用了new关键字就是创建一个对象实例，我们这里用变量a创建了一个Fn的实例（相当于复制了一份Fn到对象a里面），此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象a中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份

**当this碰到return时**

如果返回值是一个对象，那么`this`指向的就是那个返回的**对象**，如果返回值不是一个对象那么`this`还是指向函数的**实例**
虽然`null`也是对象，但是在这里`this`还是指向那个函数的实例，因为`null`比较**特殊**
``` js
function fn()  
{  
    this.user = '追梦子';  
    return {};  
}
var a = new fn;  
console.log(a.user); //undefined
```
``` js
function fn()  
{  
    this.user = '追梦子';  
    return function(){}; // 函数也是对象
}
var a = new fn;  
console.log(a.user); //undefined
```
``` js
function fn()  
{  
    this.user = '追梦子';  
    return 1;
}
var a = new fn;  
console.log(a.user); //追梦子
```
``` js
function fn()  
{  
    this.user = '追梦子';  
    return undefined;
}
var a = new fn;  
console.log(a.user); //追梦子
```
