# URL从输入到呈现

从打开浏览器输入网址, 到页面呈现，以下是总体的流程图：

**网络通信部分：**
![Image from alias](~@img/base/net-transform.png)
**浏览器解析部分：**
![Image from alias](~@img/base/browser-parsing.png)

分为6个步骤：
1. DNS解析, 将域名解析成IP地址
2. TCP连接: TCP三次握手
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 断开连接: TCP四次挥手

## 1. URL是什么?

`URL（Uniform Resource Locator）`，统一资源定位符，用于定位互联网上资源，俗称网址。

比如 `http://www.baidu.com/demo/index.html#test?a=xxx&b=xxx`，遵守以下的语法规则：

`scheme://host.domain:port/path/filename#anchor?querystring`
各部分解释如下:

- scheme: 定义Internet协议的类型, 常见的有: http, https, ftp, file, 其中最常见的就是http, 而https则是进行加密的网络传输
- host, 定义域主机(http的默认主机是www)
- domain, 域名, 比如: www.baidu.com
- port: 主机上的端口号(http的默认端口号是80)
- path: 服务器上的路径(如果省略, 则文档必须位于网站的根目录中)
- filename, 定义文档/资源的名称
- anchor，锚部分
- querystring，查询参数

## 2. 域名解析(DNS)

在浏览器输入网址后, 首先要经过域名解析, 因为浏览器并不能直接通过域名找到对应的服务器, 而是要通过IP地址.

### IP地址

IP地址是指互联网协议地址, 是IP Address的缩写. IP地址是IP地址协议提供的一种统一的地址格式, 它为互联网上的每个网格和每一台主机分配了一个逻辑地址, 以此来屏蔽物理地址的差异. IP地址是一个32位的二进制数, 比如: 127.0.0.1 为本机IP

域名的作用就是便于记忆和沟通的一组服务器地址. 用户通常使用主机名或域名来访问对方的计算机, 而不是直接通过IP地址访问. 因为与IP地址的一组纯数字相比, 用字母组合配合数字的表示形式来指定计算机名更符合人类的记忆习惯, 但要让计算机去理解名称, 相对而言就变得困难了. 因为计算机更擅长处理一长串数字. 为了解决上述问题, DNS服务应运而生

### 域名解析

DNS协议提供通过域名查找IP地址, 或逆向从IP地址反查域名的服务. DNS是一个网络服务器, 我们的域名解析简单来说就是在DNS上记录一条信息记录
例如 baidu.com 220.114.23.56（服务器外网IP地址）80（服务器端口号）

### 浏览器如何通过域名去查询URL对应的IP?

- 浏览器缓存: 浏览器会按照一定的频率缓存DNS记录
- 操作系统缓存: 如果浏览器缓存中没有找到需要的DN记录, 就会去操作系统中查找
- 路由缓存: 路由器也有DNS缓存
- ISP的DNS服务器: ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
- 根服务器: ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）

以上步骤按顺序进行，上一步骤查询到结果将不执行下一步，浏览器通过向DNS服务器发送域名, DNS服务器查询到与域名相对应的IP地址, 然后返回给浏览器, 浏览器再将IP地址打在协议上, 同时请求参数也会在协议中搭载, 然后一并发送给对应原服务器

## 3. TCP三次握手

TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。
三次握手的流程图：
![Image from alias](~@img/base/tcp.jpeg)

1. 第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认，告诉服务器我要发送请求了。
2. 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态，告诉浏览器我准备接受了，你可以发送请求了。
3. 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，告诉服务器, 我收到服务器的请求了, 现在马上发送请请给服务器，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

::: details 为什么 TCP 需要三次握手？
### 原因一：防止重复连接
三次握手的主要原因是为了防止旧的重复连接引起连接混乱问题
比如在网络状况比较复杂或者网络状况比较差的情况下，发送方可能会连续发送多次建立连接的请求。如果 TCP 握手的次数只有两次，那么接收方只能选择接受请求或者拒绝接受请求，但它并不清楚这次的请求是正常的请求，还是由于网络环境问题而导致的过期请求，如果是过期请求的话就会造成错误的连接。

所以如果 TCP 是三次握手的话，那么客户端在接收到服务器端 SEQ+1 的消息之后，就可以判断当前的连接是否为历史连接，如果判断为历史连接的话就会发送终止报文（RST）给服务器端终止连接；如果判断当前连接不是历史连接的话就会发送指令给服务器端来建立连接。
### 原因二：同步初始化序列化
通过上面的概念我们知道 TCP 的一个重要特征就是可靠性，而 TCP 为了保证在不稳定的网络环境中构建一个稳定的数据连接，它就需要一个“序列号”字段来保证自己的稳定性，而这个序列号的作用就是防止数据包重复发送，以及有效的解决数据包接收时顺序颠倒的问题。

那么在建立 TCP 连接时就需要同步初始化一个序列号来保证 TCP 的稳定性，因此它需要执行以下过程：

- 首先客户端发送一个携带了初始序列号的 SYN 报文给服务器端；

- 服务端接收到消息之后会回复一个 ACK 的应答报文，表示客户端的 SYN 报文已被服务端成功接收了；

- 而客户端收到消息之后也会发送一个 ACK 给服务端，服务器端拿到这个消息之后，我们就可以得到一个可靠的初始化序列号了。

而如果是两次握手的话，就无法进行序列号的确认工作了，因此也就无法得到一个可靠的序列号了，所以 TCP 连接至少需要三次握手。

以上两种原因就是 TCP 连接为什么需要三次握手的主要原因，当然 TCP 连接还可以四次握手，甚至是五次握手，也能实现 TCP 连接的稳定性，但三次握手是最节省资源的连接方式，因此 TCP 连接应该为三次握手。
:::

## 4. 发送HTTP请求
TCP三次握手结束后，开始发送HTTP请求报文，请求报文由请求行(`request line`), 请求头(`request header`), 请求体(`request body`)三大部分组成, 如下图所示:
![Image from alias](~@img/base/request-message.png)

### 请求行(Request Line)

包含请求方法, URL, 协议版本
- 请求方法包含8种: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, TRACE
- URL即请求地址, 由<协议>://<主机>:<端口>/<路径>?<参数> 组成
- 协议版本即HTTP版本号
 
`POST /demo/index.html HTTP/1.1`

以上代码中, "POST"代表请求方法, "/demo/index.html"表示URL, "HTTP/1.1"代表协议和协议版本

### 请求头(Request Header)
包含请求的附加信息, 由关键字/值对组成, 每行一对, 关键字生值由英文冒号":"分隔

请求头部通知服务器有关于客户端请求的信息, 它包含许多有关于客户端环境和请求正文的有用信息. 其中, 比如:
- Host, 表示主机名, 虚拟主机
- Connection: HTTP/1.1增加的, 使用keep-alive, 即持久连接, 一个连接可以发多个请求
- User-Agent, 请求发出者, 兼容性以及定制化需求

## 5. 服务器处理请求并返回HTTP报文
服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。

响应报文由响应行（request line）、响应头部（header）、响应主体（body）三个部分组成:
- 响应行, 包含协议版本, 状态码, 状态码描述
  - 状态码规则
    - 1xx, 指示信息, 表示请求已接收, 继续处理
    - 2xx, 成功, 表示请求已被成功接收和处理.
    - 3xx, 重定向, 表示要完成请求必须进行更进一步操作
    - 4xx, 客户端错误, 表示有语法错误或请求无法实现
    - 5xx, 服务器端错误, 表示服务器未能实现合法的请求
- 响应头部包含响应报文的附加信息, 由 名/值 对组成
- 响应主体包含回车符, 换行符和响应返回数据, 并不是所有响应报文都有响应数据

## 6. 浏览器解析渲染页面

浏览器解析渲染页面大致分为5个步骤:
- 根据HTML, 解析出DOM树
- 根据CSS, 解析生成CSS规则树
- 结合DOM树和CSS规则树, 生成渲染树
- 根据渲染树计算每一个节点的信息
- 根据计算好的信息绘制页面


步骤具体如下(前两步是同时进行的)：
1. 对于HTML浏览器有专门的html解析器来解析HTML，并在解析的过程中构建DOM树。在这里我们讨论两种DOM元素的解析，即样式（link、style）与脚本文件（script）。由于浏览器采用**自上而下**的方式解析，在遇到这两种元素时都会**阻塞**浏览器的**解析**，直到外部资源加载并解析或执行完毕后才会继续向下解析html。对于样式与脚本的先后顺序同样也会影响到浏览器的解析过程，究其原因主要在于：script脚本执行过程中可能会修改html界面（如document.write函数）；DOM节点的CSS样式会影响js的执行结果。在我的测试中得到以下四条结论：([参考链接](https://www.cnblogs.com/dojo-lzz/p/3983335.html))
   1. 外部样式会阻塞后续脚本执行，直到外部样式加载并解析完毕
   2. 外部样式不会阻塞后续外部脚本的加载，但会阻塞外部脚本的执行。外部脚本与外部样式是并行加载，但直到外部样式加载完毕，外部脚本才开始执行
   3. 如果后续外部脚本含有`async`属性（IE下为`defer`），则外部样式不会阻塞该脚本的加载与执行
   4. 对于动态创建的link标签不会阻塞其后动态创建的script的加载与执行，不管script标签是否具有async属性，但对于其他非动态创建的script，以上三条结论仍适用
   5. `DOMContentLoaded`和`onload`的区别：`DOMContentLoaded`在`html`解析完毕后执行，`onload`在页面完全加载完成后执行（包括样式和图片）
2. 解析css，生成CSSOM，css对象模型
3. dom和css合并，构建渲染树（Render Tree）
4. 布局（Layout）和绘制（Paint），重绘（repaint）和重排（reflow/回流）
   1. Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。 比如：页面初次渲染；浏览器窗口大小改变，DOM结构变化； render树变化，某些元素的尺寸，未知，内容变了；元素字体大小改变，激活CSS伪类（如：hover）
   2. Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。
   3. 回流一定伴随着重绘，而重绘却可以单独出现，Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。

## 7. 断开链接

当数据传送完毕, 需要断开TCP连接, 此时发起TCP四次挥手
![Image from alias](~@img/base/tcp-wave.png)
- 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
- 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
- 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
- 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)

::: details 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
### 建立连接

因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

### 关闭连接

当收到对方的FIN报文时，仅表示对方不再发送数据但还能接收收据，我们也未必把全部数据都发给了对方，所以我们可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方表示同意关闭连接。因此我们的ACK和FIN一般会分开发送。

上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图:
![Image from alias](~@img/base/tcp-wave-real.png)

:::
